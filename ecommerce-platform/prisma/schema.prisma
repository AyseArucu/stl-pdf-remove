generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// 1. KULLANICI (User)
model User {
  id       String  @id @default(cuid())
  email    String  @unique
  name     String?
  phone    String?
  image    String?
  password String? // Optional for now as legacy data might not have it or use different auth
  role     String  @default("CUSTOMER") // "ADMIN" | "SUB_ADMIN" | "CUSTOMER"
  isActive Boolean @default(true)
  emailVerified DateTime? // Null means not verified

  // RBAC Fields
  roleId      String?
  userRole    Role?            @relation(fields: [roleId], references: [id])
  permissions UserPermission[]

  orders       Order[]
  reviews      Review[]
  questions    Question[]
  favorites    Favorite[]
  stlFavorites StlFavorite[]
  cart         Cart?
  blogComments BlogComment[]
  blogPosts    BlogPost[]
  qrCodes      QrCode[]
}

// ... existing models ...

// 6. RBAC SYSTEM
model Role {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  users       User[]
  permissions RolePermission[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
}

model Permission {
  id          String           @id @default(cuid())
  key         String           @unique // e.g., "products_view"
  description String?
  module      String // e.g., "PRODUCTS"
  roles       RolePermission[]
  users       UserPermission[]
}

model RolePermission {
  id           String     @id @default(cuid())
  roleId       String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
}

model UserPermission {
  id           String     @id @default(cuid())
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([userId, permissionId])
}

model AuditLog {
  id          String   @id @default(cuid())
  action      String
  performedBy String // User ID or Email
  targetUser  String? // Target User ID or Email
  details     String? // JSON string
  createdAt   DateTime @default(now())
}

model EmailChangeToken {
  id        String   @id @default(cuid())
  userId    String
  newEmail  String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, productId])
}

// 2. KATEGORİ (Category)
model Category {
  id       String     @id @default(cuid())
  name     String
  parentId String?
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")
  products Product[]
}

// 3. ÜRÜN (Product)
model Product {
  id          String         @id @default(cuid())
  name        String
  description String
  price       Float
  stock       Int
  imageUrl    String
  media       ProductMedia[]

  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  // Extra fields
  salePrice     Float?
  color         String?
  freeShipping  Boolean  @default(false)
  rating        Float    @default(0)
  isActive      Boolean  @default(true)
  favoriteCount Int      @default(0)
  viewCount     Int      @default(0)
  createdAt     DateTime @default(now())

  // Relationships
  options    ProductOption[]
  features   ProductFeature[]
  reviews    Review[]
  questions  Question[]
  orderItems OrderItem[]

  // Many-to-Many via explicit table or implicit? keeping simple for now, 
  // but looking at db.ts "productIds: string[]" in Collection implies M-N
  collections Collection[] @relation("CollectionProducts")
  favorites   Favorite[]
  cartItems   CartItem[]
}

model ProductMedia {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  type      String // "image" | "video"
  url       String
  thumbnail String?
}

model ProductOption {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  name      String
  price     Float // Usually price difference or override
}

model ProductFeature {
  id          String  @id @default(cuid())
  productId   String
  product     Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  title       String
  description String
}

// 4. SİPARİŞ (Order)
model Order {
  id            String   @id @default(cuid())
  customerName  String
  customerEmail String
  address       String
  total         Float
  discountTotal Float?
  status        String // "Hazırlanıyor", "Kargolandı", "Teslim Edildi", "İptal"
  paymentMethod String // "CREDIT_CARD", "BANK_TRANSFER", "COD"
  paymentStatus String // "PENDING", "PAID", "FAILED"
  date          DateTime @default(now())

  // Link to User if logged in
  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  items OrderItem[]
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId String?
  product   Product? @relation(fields: [productId], references: [id])

  stlModelId String?
  stlModel   StlModel? @relation(fields: [stlModelId], references: [id])

  productName String // Snapshot of name
  quantity    Int
  price       Float
}

// 5. DİĞERLERİ
model Review {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  userName  String
  rating    Int
  comment   String
  createdAt DateTime @default(now())
}

model Question {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  userName  String
  question  String
  answer    String?
  createdAt DateTime @default(now())
}

model Collection {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  description String?
  imageUrl    String?
  isActive    Boolean   @default(true)
  products    Product[] @relation("CollectionProducts")
}

model Discount {
  id         String   @id @default(cuid())
  name       String
  percentage Float
  isActive   Boolean  @default(true)
  startDate  DateTime
  endDate    DateTime
}

model ContactMessage {
  id      String   @id @default(cuid())
  name    String
  email   String
  subject String
  message String
  date    DateTime @default(now())
}

model ServiceRequest {
  id               String   @id @default(cuid())
  name             String
  email            String
  phone            String
  siteType         String // "CORPORATE", "ECOMMERCE", etc.
  pageCount        String
  specialRequests  String?
  budget           String?
  status           String   @default("NEW")
  adminNotes       String?
  offerPrice       Float?
  offerDescription String?
  paymentToken     String?
  createdAt        DateTime @default(now())
}

model FAQItem {
  id       String @id @default(cuid())
  question String
  answer   String
}

model ContactSettings {
  id        String  @id @default(cuid())
  address   String
  mapUrl    String
  phone     String?
  email     String?
  instagram String?
  twitter   String?
  facebook  String?
  linkedin  String?
  youtube   String?
}

model HeroSlide {
  id          String   @id @default(cuid())
  title       String
  subtitle    String?
  description String?
  imageUrl    String
  buttonText  String   @default("Koleksiyonu Keşfet")
  buttonLink  String   @default("/collections")
  order       Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ServicePageContent {
  id              String @id @default(cuid())
  heroTitle       String
  heroDescription String
  benefits        String // JSON string
  whyUsText       String
  stats           String // JSON string
  packages        String // JSON string
  faqs            String // JSON string
  whatsappNumber  String
  whatsappMessage String
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
}

model Cart {
  id        String     @id @default(cuid())
  userId    String?    @unique
  user      User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

// 5. DİĞERLERİ

// ... (Reviews, Questions, etc. omitted for brevity, keeping file intact)
// But I need to preserve the middle part. The tool replaces contiguous block.
// I will replace OrderItem, CartItem, StlModel, and add StlCategory.

model CartItem {
  id     String @id @default(cuid())
  cartId String
  cart   Cart   @relation(fields: [cartId], references: [id], onDelete: Cascade)

  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: Cascade)

  stlModelId String?
  stlModel   StlModel? @relation(fields: [stlModelId], references: [id], onDelete: Cascade)

  quantity  Int
  price     Float // Snapshot price or can be derived
  createdAt DateTime @default(now())

  // Unique constraint might need adjustment or separate them. 
  // @@unique([cartId, productId]) -> Cannot enforce easily with optional fields in standard way without partial index or just let app handle it.
  // For SQLite, standard unique constraint checks non-nulls.
  // We can just rely on app logic for now or remove unique constraint.
}

model StlCategory {
  id       String     @id @default(cuid())
  name     String
  slug     String?    @unique // Optional to avoid breaking existing
  isActive Boolean    @default(true)
  models   StlModel[]
}

model StlModel {
  id          String   @id @default(cuid())
  name        String
  description String
  fileUrl     String
  imageUrl    String
  price       Float    @default(0)
  isFree      Boolean  @default(false)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  categoryId String?
  category   StlCategory? @relation(fields: [categoryId], references: [id])

  viewCount     Int @default(0)
  downloadCount Int @default(0)
  favoriteCount Int @default(0)

  tags StlTag[] @relation("StlModelTags")

  cartItems  CartItem[]
  orderItems OrderItem[]
  favorites  StlFavorite[]
}

model StlFavorite {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stlModelId String
  stlModel   StlModel @relation(fields: [stlModelId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([userId, stlModelId])
}

model StlTag {
  id     String     @id @default(cuid())
  name   String     @unique
  models StlModel[] @relation("StlModelTags")
}

model ShippingSettings {
  id                    String  @id @default(cuid())
  shippingCost          Float   @default(0)
  freeShippingThreshold Float?
  isActive              Boolean @default(true)
}

model BlogPost {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  coverImage  String
  excerpt     String
  content     String
  category    String // "Blog" | "Haber"
  published   Boolean  @default(true)
  viewCount   Int      @default(0)
  author      String?  // Display name (Legacy or manual override)
  authorId    String?
  authorUser  User?    @relation(fields: [authorId], references: [id])
  images      String?  // JSON string for extra images
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  comments    BlogComment[]
}

model BlogComment {
  id        String   @id @default(cuid())
  content   String
  postId    String
  post      BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  authorName String?
  authorSurname String?
  createdAt DateTime @default(now())
  
  // Replies
  parentId  String?
  parent    BlogComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   BlogComment[] @relation("CommentReplies")
}

model QrCode {
  id          String   @id @default(cuid())
  type        String   @default("url") // "url", "video", "vcard", "pdf", "image", "audio", "app", "wifi", "text"
  targetUrl   String?  // Optional because some types (like vCard) might just render data directly or use internal routing
  data        String?  // JSON string for rich data (vCard fields, Media URLs, etc.)
  name        String?
  password    String?
  viewCount   Int      @default(0)
  design      String?  // JSON string for colors, shapes, logo, etc.
  
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Advertisement {
  id        String   @id @default(cuid())
  title     String
  type      String   // "IMAGE" | "HTML" | "VIDEO"
  content   String   // Image URL, Video URL, or HTML Code
  location  String   // Removed @unique to allow multiple ads per location
  duration  Int      @default(5) // Duration in seconds
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  @@unique([email, token])
}
